package ccc18TestIntensiveExample

import scala.language.existentials

import chisel3._
import chisel3.util._

// Note: without the Bundle literals stuff, this could be inlined into the Gcd io def
class GcdInputBundle(val w: Int) extends Bundle {
  val a = UInt(w.W)
  val b = UInt(w.W)

  // IGNORE THIS - this is some boilerplate Bundle Literals code
  // and would be auto-generated by an upcoming feature
  def Lit(aVal: UInt, bVal: UInt) = {
    import chisel3.core.BundleLitBinding
    val clone = cloneType
    clone.selfBind(BundleLitBinding(Map(
      clone.a -> litArgOfBits(aVal),
      clone.b -> litArgOfBits(bVal)
    )))
    clone
  }
}

class Gcd(width: Int) extends Module {
  val io = IO(new Bundle {
    val in = Flipped(Decoupled(new GcdInputBundle(width)))
    val out = Decoupled(UInt(width.W))
  })

  val x = RegInit(0.U(width.W))
  val y = Reg(UInt(width.W))

  when (x > y) {
    x := x -% y
  } .otherwise {
    y := y -% x
  }

  when (io.in.valid) { x := io.in.bits.a; y := io.in.bits.b }
  io.out.bits := x
  io.out.valid := y === 0.U && !io.in.valid
  io.in.ready := y === 0.U

  // For debugging, we can have internal state printed out every cycle.
  // See https://github.com/freechipsproject/chisel3/wiki/Printing-in-Chisel
//  printf(p"x=$x, y=$y, v=${io.out.valid}\n")

  // Prints can also be gated on a condition, eg if we only wanted to print when we have a solution
//  when (io.in.valid && io.in.ready) {
//    printf(p"input a=${io.in.bits.a}, b=${io.in.bits.b}\n")
//  }
//  when (io.out.valid) {
//    printf(p"result=${io.out.bits}, v=${io.out.valid}\n")
//  }

  // Note: we kind of ignore output ready here, so this is a misuse of Decoupled
  // since backpressure is ignored.
}
